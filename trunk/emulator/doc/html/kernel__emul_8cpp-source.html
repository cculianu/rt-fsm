<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>FSMEmulator: kernel_emul.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>kernel_emul.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include "kernel_emul.h"</span>
<a name="l00002"></a>00002 <span class="preprocessor">#undef timespec_add_ns</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#undef clock_gettime</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor">#include "rtos_utility.h"</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;stdio.h&gt;</span> <span class="comment">/* for now, all rt_printks go to stdout.. */</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "ComediEmul.h"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;semaphore.h&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#ifdef OS_WINDOWS</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#endif</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">namespace </span>Emul {
<a name="l00017"></a>00017 
<a name="l00018"></a>00018     <span class="keyword">static</span> ModuleParmMap *moduleParms = 0;
<a name="l00019"></a>00019 
<a name="l00020"></a>00020     <span class="keyword">static</span> std::ostringstream procFileEmulStream;
<a name="l00021"></a>00021 
<a name="l00022"></a>00022     std::string readFSMProcFile()
<a name="l00023"></a>00023     {
<a name="l00024"></a>00024         procFileEmulStream.str(<span class="stringliteral">""</span>);
<a name="l00025"></a>00025         <span class="keywordflow">if</span> (fsm_seq_show_func) {
<a name="l00026"></a>00026             fsm_seq_show_func(0, 0);            
<a name="l00027"></a>00027         }
<a name="l00028"></a>00028         <span class="keywordflow">return</span> procFileEmulStream.str();
<a name="l00029"></a>00029     }
<a name="l00030"></a>00030     
<a name="l00031"></a>00031     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> tickCount = 0;
<a name="l00032"></a>00032     <span class="keyword">static</span> <span class="keywordtype">int</span> *taskRate_ptr = 0;
<a name="l00033"></a>00033 
<a name="l00034"></a>00034     <span class="keywordtype">long</span> <span class="keywordtype">long</span> taskRate()
<a name="l00035"></a>00035     {
<a name="l00036"></a>00036         <span class="keywordflow">if</span> (!taskRate_ptr) {
<a name="l00037"></a>00037             <span class="keywordflow">if</span> (!getModuleParm(<span class="stringliteral">"task_rate"</span>, taskRate_ptr)) {
<a name="l00038"></a>00038                 fprintf(stderr, <span class="stringliteral">"MAJOR ERROR: No fsm task_rate module parm found in Emul::taskRate()\n"</span>);
<a name="l00039"></a>00039             }
<a name="l00040"></a>00040         }
<a name="l00041"></a>00041         <span class="keywordflow">if</span> (taskRate_ptr) <span class="keywordflow">return</span> *taskRate_ptr;
<a name="l00042"></a>00042         <span class="keywordflow">return</span> 6000; <span class="comment">// default if error above</span>
<a name="l00043"></a>00043     }
<a name="l00044"></a>00044     
<a name="l00045"></a>00045     hrtime_t getTime() 
<a name="l00046"></a>00046     {
<a name="l00047"></a>00047         <span class="keywordflow">return</span> tickCount * (1000000000LL/taskRate());
<a name="l00048"></a>00048     }
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 
<a name="l00051"></a>00051     <span class="comment">/*</span>
<a name="l00052"></a>00052 <span class="comment">    static unsigned long long time2TickCount(hrtime_t t)</span>
<a name="l00053"></a>00053 <span class="comment">    {</span>
<a name="l00054"></a>00054 <span class="comment">        return static_cast&lt;unsigned long long&gt;(t/(1000000000LL/taskRate()));</span>
<a name="l00055"></a>00055 <span class="comment">    }</span>
<a name="l00056"></a>00056 <span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">    struct Sleeper </span>
<a name="l00058"></a>00058 <span class="comment">    {</span>
<a name="l00059"></a>00059 <span class="comment">        sem_t sem;</span>
<a name="l00060"></a>00060 <span class="comment">        unsigned long long wakeup; ///&lt; tick at which to wakeup</span>
<a name="l00061"></a>00061 <span class="comment">        Sleeper() : wakeup(0)  {  sem_init(&amp;sem, 0, 0);     }</span>
<a name="l00062"></a>00062 <span class="comment">        ~Sleeper() {  sem_destroy(&amp;sem);   }</span>
<a name="l00063"></a>00063 <span class="comment">    };</span>
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">    typedef std::multimap&lt;unsigned long long, Sleeper *&gt; SleeperMap;</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">    static SleeperMap sleepers;</span>
<a name="l00068"></a>00068 <span class="comment">    static pthread_mutex_t sleeperLock = PTHREAD_MUTEX_INITIALIZER;</span>
<a name="l00069"></a>00069 <span class="comment">  </span>
<a name="l00070"></a>00070 <span class="comment">    void heartBeat() </span>
<a name="l00071"></a>00071 <span class="comment">    {</span>
<a name="l00072"></a>00072 <span class="comment">        ++tickCount; // advance the tick count</span>
<a name="l00073"></a>00073 <span class="comment">        SleeperMap::iterator it;</span>
<a name="l00074"></a>00074 <span class="comment">        pthread_mutex_lock(&amp;sleeperLock);</span>
<a name="l00075"></a>00075 <span class="comment">        // now wake all sleepers whose wakeuptime &lt;= current tick count</span>
<a name="l00076"></a>00076 <span class="comment">        while ( (it = sleepers.begin()) != sleepers.end() &amp;&amp; it-&gt;first &lt;= tickCount ) {</span>
<a name="l00077"></a>00077 <span class="comment">            Sleeper *s = it-&gt;second;</span>
<a name="l00078"></a>00078 <span class="comment">            sleepers.erase(it);</span>
<a name="l00079"></a>00079 <span class="comment">            sem_post(&amp;s-&gt;sem);</span>
<a name="l00080"></a>00080 <span class="comment">        }</span>
<a name="l00081"></a>00081 <span class="comment">        pthread_mutex_unlock(&amp;sleeperLock);</span>
<a name="l00082"></a>00082 <span class="comment">    }</span>
<a name="l00083"></a>00083 <span class="comment">    */</span>
<a name="l00084"></a>00084     <span class="keyword">static</span> <span class="keywordtype">void</span> heartBeat() { ++tickCount; }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086     <span class="keywordtype">bool</span> fastFSM = <span class="keyword">false</span>;
<a name="l00087"></a>00087     
<a name="l00088"></a>00088     <span class="comment">// clock latch stuff -- note all times are in EMULATOR time not wall-clock time</span>
<a name="l00089"></a>00089     <span class="keyword">static</span> pthread_mutex_t latchMut = PTHREAD_MUTEX_INITIALIZER;
<a name="l00090"></a>00090     <span class="keyword">static</span> pthread_cond_t  latchCond = PTHREAD_COND_INITIALIZER;
<a name="l00091"></a>00091     <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">long</span> latchTimeNanos = 0;
<a name="l00092"></a>00092     <span class="keyword">static</span> hrtime_t lastLatchTime = 0;
<a name="l00093"></a>00093     
<a name="l00094"></a>00094     <span class="comment">/* Provide clock_gettime() emulation using gettimeofday </span>
<a name="l00095"></a>00095 <span class="comment">       on OSX and on Windows */</span>
<a name="l00096"></a>00096 <span class="preprocessor">#if defined(OS_OSX) || defined(WIN32) || defined(OS_WINDOWS)</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>    <span class="comment">/* OSX has this function, windows does not */</span>
<a name="l00099"></a>00099     <span class="keyword">static</span> <span class="keywordtype">void</span> TIMEVAL_TO_TIMESPEC(<span class="keyword">const</span> <span class="keyword">struct</span> timeval *tv,
<a name="l00100"></a>00100                                     <span class="keyword">struct</span> timespec *ts)
<a name="l00101"></a>00101     {
<a name="l00102"></a>00102         ts-&gt;tv_sec = tv-&gt;tv_sec;
<a name="l00103"></a>00103         ts-&gt;tv_nsec = tv-&gt;tv_usec*1000;
<a name="l00104"></a>00104         <span class="keywordflow">if</span> (ts-&gt;tv_nsec &gt;= 1000000000) ts-&gt;tv_nsec -= 1000000000, ++ts-&gt;tv_sec;
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106 <span class="preprocessor">#endif</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>    <span class="keywordtype">int</span> clock_gettime(<span class="keywordtype">int</span> clkid, <span class="keyword">struct</span> timespec *ts)
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109         <span class="keyword">struct </span>timeval tv;
<a name="l00110"></a>00110         <span class="keywordtype">int</span> ret = gettimeofday(&amp;tv, 0);
<a name="l00111"></a>00111         (void)clkid;
<a name="l00112"></a>00112         TIMEVAL_TO_TIMESPEC(&amp;tv, ts);
<a name="l00113"></a>00113         <span class="keywordflow">return</span> ret;
<a name="l00114"></a>00114     }
<a name="l00115"></a>00115 <span class="preprocessor">#endif</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>
<a name="l00117"></a>00117 <span class="preprocessor">#ifdef OS_OSX</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>    <span class="keyword">static</span> pthread_cond_t nscond = PTHREAD_COND_INITIALIZER;
<a name="l00119"></a>00119     <span class="keyword">static</span> pthread_mutex_t nsmut = PTHREAD_MUTEX_INITIALIZER;
<a name="l00120"></a>00120     <span class="keywordtype">void</span> nanosleep(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nanos)
<a name="l00121"></a>00121     {
<a name="l00122"></a>00122         <span class="keyword">struct </span>timespec ts;
<a name="l00123"></a>00123         clock_gettime(CLOCK_REALTIME, &amp;ts);
<a name="l00124"></a>00124         ts.tv_nsec += nanos;
<a name="l00125"></a>00125         <span class="keywordflow">while</span> (ts.tv_nsec &gt;= 1000000000) ++ts.tv_sec, ts.tv_nsec -= 1000000000;
<a name="l00126"></a>00126         pthread_mutex_lock(&amp;nsmut);
<a name="l00127"></a>00127         pthread_cond_timedwait(&amp;nscond, &amp;nsmut, &amp;ts);
<a name="l00128"></a>00128         pthread_mutex_unlock(&amp;nsmut);
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130 <span class="preprocessor">#elif defined(WIN32) &amp;&amp; !defined(CYGWIN)</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>    <span class="keywordtype">void</span> nanosleep(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nanos)
<a name="l00132"></a>00132     {
<a name="l00133"></a>00133         HANDLE hTimer = NULL;
<a name="l00134"></a>00134         LARGE_INTEGER liDueTime;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136         liDueTime.QuadPart = -<span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(nanos/100UL);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         <span class="comment">// Create a waitable timer.</span>
<a name="l00139"></a>00139         <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> i = 0;
<a name="l00140"></a>00140         std::ostringstream os;
<a name="l00141"></a>00141         os &lt;&lt; <span class="stringliteral">"WaitableTimer"</span> &lt;&lt; ++i;
<a name="l00142"></a>00142         hTimer = CreateWaitableTimerA(NULL, TRUE, os.str().c_str());
<a name="l00143"></a>00143         <span class="keywordflow">if</span> (hTimer &amp;&amp; SetWaitableTimer(hTimer, &amp;liDueTime, 0, NULL, NULL, 0))
<a name="l00144"></a>00144         {
<a name="l00145"></a>00145             <span class="comment">// Wait for the timer.</span>
<a name="l00146"></a>00146             WaitForSingleObject(hTimer, INFINITE);
<a name="l00147"></a>00147         }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         CloseHandle(hTimer);
<a name="l00150"></a>00150     }
<a name="l00151"></a>00151 <span class="preprocessor">#else</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span>    using ::clock_gettime;
<a name="l00153"></a>00153     <span class="keywordtype">void</span> nanosleep(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nanos)
<a name="l00154"></a>00154     {
<a name="l00155"></a>00155         <span class="keyword">static</span> sem_t sem;
<a name="l00156"></a>00156         <span class="keyword">static</span> <span class="keywordtype">bool</span> didinit = <span class="keyword">false</span>;
<a name="l00157"></a>00157         <span class="keywordflow">if</span> (!didinit) {
<a name="l00158"></a>00158             didinit = <span class="keyword">true</span>;
<a name="l00159"></a>00159             sem_init(&amp;sem, 0, 0);
<a name="l00160"></a>00160         }
<a name="l00161"></a>00161         <span class="keyword">struct </span>timespec ts;
<a name="l00162"></a>00162         clock_gettime(CLOCK_REALTIME, &amp;ts);
<a name="l00163"></a>00163         ts.tv_nsec += nanos;
<a name="l00164"></a>00164         <span class="keywordflow">while</span> (ts.tv_nsec &gt;= 1000000000) ++ts.tv_sec, ts.tv_nsec -= 1000000000;
<a name="l00165"></a>00165         sem_timedwait(&amp;sem, &amp;ts);
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>
<a name="l00169"></a>00169     <span class="keyword">const</span> ModuleParmMap &amp; getModuleParms()
<a name="l00170"></a>00170     {
<a name="l00171"></a>00171         <span class="keyword">static</span> <span class="keyword">const</span> ModuleParmMap dummyMap;
<a name="l00172"></a>00172         <span class="keywordflow">return</span> moduleParms ? *moduleParms : dummyMap;
<a name="l00173"></a>00173     }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <span class="keywordtype">bool</span> getModuleParm(<span class="keyword">const</span> std::string &amp; name, <span class="keywordtype">int</span> &amp; val_out)
<a name="l00176"></a>00176     {
<a name="l00177"></a>00177         <span class="keyword">const</span> ModuleParmMap &amp; m = getModuleParms();
<a name="l00178"></a>00178         ModuleParmMap::const_iterator it = m.find(name);
<a name="l00179"></a>00179         <span class="keywordflow">if</span> (it != m.end() &amp;&amp; it-&gt;second.type == ModuleParm::Int) {
<a name="l00180"></a>00180             val_out = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(it-&gt;second.p);
<a name="l00181"></a>00181             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00182"></a>00182         }
<a name="l00183"></a>00183         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <span class="keywordtype">bool</span> getModuleParm(<span class="keyword">const</span> std::string &amp; name, <span class="keywordtype">int</span> * &amp; val_out)
<a name="l00187"></a>00187     {
<a name="l00188"></a>00188         <span class="keyword">const</span> ModuleParmMap &amp; m = getModuleParms();
<a name="l00189"></a>00189         ModuleParmMap::const_iterator it = m.find(name);
<a name="l00190"></a>00190         <span class="keywordflow">if</span> (it != m.end() &amp;&amp; it-&gt;second.type == ModuleParm::Int) {
<a name="l00191"></a>00191             val_out = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(it-&gt;second.p);
<a name="l00192"></a>00192             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00193"></a>00193         }
<a name="l00194"></a>00194         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <span class="keywordtype">bool</span> getModuleParm(<span class="keyword">const</span> std::string &amp; name, std::string &amp; val_out)
<a name="l00198"></a>00198     {
<a name="l00199"></a>00199         <span class="keyword">const</span> ModuleParmMap &amp; m = getModuleParms();
<a name="l00200"></a>00200         ModuleParmMap::const_iterator it = m.find(name);
<a name="l00201"></a>00201         <span class="keywordflow">if</span> (it != m.end() &amp;&amp; it-&gt;second.type == ModuleParm::CharP) {
<a name="l00202"></a>00202             val_out = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> **<span class="keyword">&gt;</span>(it-&gt;second.p);
<a name="l00203"></a>00203             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     PrintFunctor::~PrintFunctor() { <span class="comment">/* noop */</span> }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     <span class="keywordtype">void</span> setModuleParm(<span class="keyword">const</span> std::string &amp; name, <span class="keywordtype">int</span> val)
<a name="l00211"></a>00211     {
<a name="l00212"></a>00212         <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l00213"></a>00213         <span class="keywordflow">if</span> (moduleParms) {
<a name="l00214"></a>00214             ModuleParmMap::iterator it = moduleParms-&gt;find(name);
<a name="l00215"></a>00215             <span class="keywordflow">if</span> (it != moduleParms-&gt;end()) {
<a name="l00216"></a>00216                 <span class="keywordflow">if</span> (it-&gt;second.type == ModuleParm::Int) {
<a name="l00217"></a>00217                     <span class="keywordtype">int</span> &amp; parm = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(it-&gt;second.p);
<a name="l00218"></a>00218                     parm = val;
<a name="l00219"></a>00219                     found = <span class="keyword">true</span>;
<a name="l00220"></a>00220                 }
<a name="l00221"></a>00221             }
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223         <span class="keywordflow">if</span> (!found) printf(<span class="stringliteral">"module parm %s not set!\n"</span>, name.c_str());
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     <span class="keywordtype">void</span> setModuleParm(<span class="keyword">const</span> std::string &amp; name, <span class="keyword">const</span> <span class="keywordtype">char</span> *val)
<a name="l00227"></a>00227     {
<a name="l00228"></a>00228         <span class="keywordflow">if</span> (moduleParms) {
<a name="l00229"></a>00229             ModuleParmMap::iterator it = moduleParms-&gt;find(name);
<a name="l00230"></a>00230             <span class="keywordflow">if</span> (it != moduleParms-&gt;end()) {
<a name="l00231"></a>00231                 <span class="keywordflow">if</span> (it-&gt;second.type == ModuleParm::CharP) {
<a name="l00232"></a>00232                     <span class="keywordtype">char</span> * &amp; parm = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> **<span class="keyword">&gt;</span>(it-&gt;second.p);
<a name="l00233"></a>00233                     parm = strdup(val); <span class="comment">// HACK! WARNING! FIXME!! Possible memory leak here!</span>
<a name="l00234"></a>00234                 }
<a name="l00235"></a>00235             }
<a name="l00236"></a>00236         }        
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keyword">static</span> PrintFunctor *printFunctor = 0;
<a name="l00240"></a>00240     
<a name="l00241"></a>00241     <span class="keywordtype">void</span> setPrintFunctor(PrintFunctor *functor)
<a name="l00242"></a>00242     {
<a name="l00243"></a>00243         printFunctor = functor;
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245 } 
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="keywordtype">void</span> latchCountdownReset(<span class="keywordtype">long</span> <span class="keywordtype">long</span> ts) 
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254         <span class="keywordflow">if</span> (ts &lt; 0) ts = Emul::getTime();
<a name="l00255"></a>00255         pthread_mutex_lock(&amp;Emul::latchMut);
<a name="l00256"></a>00256         Emul::lastLatchTime = ts;
<a name="l00257"></a>00257         pthread_cond_broadcast(&amp;Emul::latchCond);
<a name="l00258"></a>00258         pthread_mutex_unlock(&amp;Emul::latchMut);
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260     
<a name="l00261"></a>00261     <span class="keywordtype">long</span> getLatchTimeNanos(<span class="keywordtype">void</span>)
<a name="l00262"></a>00262     {
<a name="l00263"></a>00263         <span class="keywordflow">return</span> Emul::latchTimeNanos;
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265 
<a name="l00266"></a>00266     <span class="keywordtype">void</span> setLatchTimeNanos(<span class="keywordtype">long</span> ns)
<a name="l00267"></a>00267     {
<a name="l00268"></a>00268         pthread_mutex_lock(&amp;Emul::latchMut);
<a name="l00269"></a>00269         Emul::latchTimeNanos = ns;
<a name="l00270"></a>00270         pthread_cond_broadcast(&amp;Emul::latchCond);
<a name="l00271"></a>00271         pthread_mutex_unlock(&amp;Emul::latchMut);        
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     <span class="keyword">static</span> <span class="keywordtype">int</span> isClockLatched_Nolock(<span class="keywordtype">void</span>)
<a name="l00275"></a>00275     {
<a name="l00276"></a>00276         hrtime_t now = Emul::getTime();
<a name="l00277"></a>00277         <span class="comment">/*        fprintf(stderr, "now: %llu  latchtime: %ld  lastlatchtime: %lld\n",</span>
<a name="l00278"></a>00278 <span class="comment">                  now, Emul::latchTimeNanos, Emul::lastLatchTime);*/</span>
<a name="l00279"></a>00279         <span class="keywordflow">return</span> Emul::latchTimeNanos &gt; 0 
<a name="l00280"></a>00280                &amp;&amp; now-Emul::lastLatchTime &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(Emul::latchTimeNanos);
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282     <span class="keywordtype">int</span> isClockLatched(<span class="keywordtype">void</span>)
<a name="l00283"></a>00283     {
<a name="l00284"></a>00284         pthread_mutex_lock(&amp;Emul::latchMut);
<a name="l00285"></a>00285         <span class="keywordtype">int</span> ret = isClockLatched_Nolock();
<a name="l00286"></a>00286         pthread_mutex_unlock(&amp;Emul::latchMut);        
<a name="l00287"></a>00287         <span class="keywordflow">return</span> ret;
<a name="l00288"></a>00288     }
<a name="l00289"></a>00289 
<a name="l00291"></a>00291     <span class="keywordtype">long</span> <span class="keywordtype">long</span> getLatchT0Nanos(<span class="keywordtype">void</span>)
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293         pthread_mutex_lock(&amp;Emul::latchMut);
<a name="l00294"></a>00294         <span class="keywordtype">long</span> <span class="keywordtype">long</span> ret = Emul::lastLatchTime;
<a name="l00295"></a>00295         pthread_mutex_unlock(&amp;Emul::latchMut);
<a name="l00296"></a>00296         <span class="keywordflow">return</span> ret;
<a name="l00297"></a>00297     }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="comment">/* mbuff stuff */</span>
<a name="l00300"></a>00300 <span class="keywordtype">void</span> *mbuff_alloc(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size)
<a name="l00301"></a>00301 {
<a name="l00302"></a>00302     <span class="keywordflow">return</span> RTOS::shmAttach(name, size, 0, <span class="keyword">true</span>);    
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 <span class="keywordtype">void</span> *mbuff_attach(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size)
<a name="l00305"></a>00305 {
<a name="l00306"></a>00306     <span class="keywordflow">return</span> RTOS::shmAttach(name, size, 0, <span class="keyword">false</span>);    
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 <span class="keywordtype">void</span>  mbuff_detach(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">void</span> *mem)
<a name="l00309"></a>00309 {
<a name="l00310"></a>00310     (void)name;
<a name="l00311"></a>00311     RTOS::shmDetach(mem, 0, <span class="keyword">false</span>);
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 <span class="keywordtype">void</span>  mbuff_free(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">void</span> *mem)
<a name="l00314"></a>00314 {
<a name="l00315"></a>00315     (void)name;
<a name="l00316"></a>00316     RTOS::shmDetach(mem, 0, <span class="keyword">true</span>);
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">/* fifo stuff */</span>
<a name="l00320"></a>00320 <span class="keywordtype">int</span> rtf_find_free(<span class="keywordtype">unsigned</span> *minor_out, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size)
<a name="l00321"></a>00321 {    
<a name="l00322"></a>00322     <span class="keywordflow">return</span> 0 == RTOS::createFifo(*minor_out, size);
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 <span class="keywordtype">int</span> rtf_destroy(<span class="keywordtype">unsigned</span> fifo)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     RTOS::closeFifo(fifo);
<a name="l00327"></a>00327     <span class="keywordflow">return</span> 0;
<a name="l00328"></a>00328 }
<a name="l00329"></a>00329 <span class="keywordtype">int</span> rtf_put(<span class="keywordtype">unsigned</span> fifo, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331     <span class="keywordflow">return</span> RTOS::writeFifo(fifo, data, size, <span class="keyword">false</span>);
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 <span class="keywordtype">int</span> rtf_get_if(<span class="keywordtype">unsigned</span> fifo, <span class="keywordtype">void</span> *data, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size)
<a name="l00334"></a>00334 {
<a name="l00335"></a>00335     <span class="keywordflow">return</span> RTOS::readFifo(fifo, data, size, <span class="keyword">false</span>);
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 <span class="keywordtype">int</span> RTF_FREE(<span class="keywordtype">unsigned</span> minor)
<a name="l00338"></a>00338 {
<a name="l00339"></a>00339     rt_printk(<span class="stringliteral">"INTENRAL ERROR: RTF_FREE unimplemented!\n"</span>);
<a name="l00340"></a>00340     (void)minor;
<a name="l00341"></a>00341     <span class="keywordflow">return</span> 0;
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="keyword">static</span> pthread_mutex_t critical_mutex = PTHREAD_MUTEX_INITIALIZER;
<a name="l00345"></a>00345 <span class="keywordtype">long</span> rt_start_critical(<span class="keywordtype">void</span>)
<a name="l00346"></a>00346 {
<a name="l00347"></a>00347     pthread_mutex_lock(&amp;critical_mutex);
<a name="l00348"></a>00348     <span class="keywordflow">return</span> 0;
<a name="l00349"></a>00349 }
<a name="l00350"></a>00350 <span class="keywordtype">void</span> rt_end_critical(<span class="keywordtype">long</span> flags)
<a name="l00351"></a>00351 {
<a name="l00352"></a>00352     (void)flags;
<a name="l00353"></a>00353     pthread_mutex_unlock(&amp;critical_mutex);
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="keyword">struct </span>SoftTask
<a name="l00357"></a>00357 {
<a name="l00358"></a>00358     SoftTask_Handler handler;
<a name="l00359"></a>00359     std::string name;
<a name="l00360"></a>00360     <span class="keywordtype">void</span> *arg;
<a name="l00361"></a>00361     <span class="keyword">static</span> <span class="keywordtype">void</span> *fun(<span class="keywordtype">void</span> *arg) {
<a name="l00362"></a>00362         SoftTask *s = <span class="keyword">reinterpret_cast&lt;</span>SoftTask *<span class="keyword">&gt;</span>(arg);
<a name="l00363"></a>00363         s-&gt;handler(s-&gt;arg);
<a name="l00364"></a>00364         <span class="keywordflow">return</span> 0;
<a name="l00365"></a>00365     }
<a name="l00366"></a>00366 };
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 SoftTask *softTaskCreate(SoftTask_Handler fun, <span class="keyword">const</span> <span class="keywordtype">char</span> *task)
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370     SoftTask *s = <span class="keyword">new</span> SoftTask;
<a name="l00371"></a>00371     s-&gt;name = task;
<a name="l00372"></a>00372     s-&gt;handler = fun;
<a name="l00373"></a>00373     <span class="keywordflow">return</span> s;
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 <span class="keywordtype">void</span> softTaskDestroy(<span class="keyword">struct</span> SoftTask *s)
<a name="l00377"></a>00377 {
<a name="l00378"></a>00378     s-&gt;handler = 0;
<a name="l00379"></a>00379     s-&gt;name = <span class="stringliteral">""</span>;
<a name="l00380"></a>00380     <span class="keyword">delete</span> s;
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="keywordtype">int</span> softTaskPend(<span class="keyword">struct</span> SoftTask *s, <span class="keywordtype">void</span> *arg)
<a name="l00384"></a>00384 {
<a name="l00385"></a>00385     pthread_t thr;
<a name="l00386"></a>00386     pthread_attr_t attr;
<a name="l00387"></a>00387     pthread_attr_init(&amp;attr);
<a name="l00388"></a>00388     pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
<a name="l00389"></a>00389     s-&gt;arg = arg;
<a name="l00390"></a>00390     <span class="keywordtype">int</span> ret = pthread_create(&amp;thr, &amp;attr, SoftTask::fun, reinterpret_cast&lt;void *&gt;(s));
<a name="l00391"></a>00391     pthread_attr_destroy(&amp;attr);
<a name="l00392"></a>00392     <span class="keywordflow">return</span> ret;
<a name="l00393"></a>00393 }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 comedi_t *comedi_open(<span class="keyword">const</span> <span class="keywordtype">char</span> *devfile)
<a name="l00396"></a>00396 {
<a name="l00397"></a>00397     <span class="keywordflow">return</span> ComediEmul::getInstance(devfile);
<a name="l00398"></a>00398 }
<a name="l00399"></a>00399 <span class="keywordtype">int</span> comedi_close(comedi_t *d)
<a name="l00400"></a>00400 {
<a name="l00401"></a>00401     ComediEmul::putInstance(d);
<a name="l00402"></a>00402     <span class="keywordflow">return</span> 0;
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 <span class="keywordtype">int</span> comedi_lock(comedi_t *d, <span class="keywordtype">unsigned</span> sd)
<a name="l00405"></a>00405 {
<a name="l00406"></a>00406     (void)d; (void)sd; <span class="keywordflow">return</span> -ENOSYS;
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 <span class="keywordtype">int</span> comedi_unlock(comedi_t *d, <span class="keywordtype">unsigned</span> sd)
<a name="l00409"></a>00409 {
<a name="l00410"></a>00410     (void)d; (void)sd; <span class="keywordflow">return</span> -ENOSYS;
<a name="l00411"></a>00411 }
<a name="l00412"></a>00412 <span class="keywordtype">int</span> comedi_cancel(comedi_t *d, <span class="keywordtype">unsigned</span> sd)
<a name="l00413"></a>00413 {
<a name="l00414"></a>00414     (void)d; (void)sd; <span class="keywordflow">return</span> -ENOSYS;
<a name="l00415"></a>00415 }
<a name="l00416"></a>00416 <span class="keywordtype">int</span> comedi_find_subdevice_by_type(comedi_t *dev, <span class="keywordtype">int</span> type, <span class="keywordtype">unsigned</span> first_sd)
<a name="l00417"></a>00417 {
<a name="l00418"></a>00418     <span class="keywordflow">return</span> dev-&gt;findByType(type, first_sd);
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 <span class="keywordtype">int</span> comedi_get_n_channels(comedi_t *dev, <span class="keywordtype">unsigned</span> sd)
<a name="l00421"></a>00421 {
<a name="l00422"></a>00422     <span class="keywordflow">return</span> dev-&gt;getNChans(sd);
<a name="l00423"></a>00423 }
<a name="l00424"></a>00424 <span class="keywordtype">int</span> comedi_get_n_ranges(comedi_t *dev, <span class="keywordtype">unsigned</span> sd, <span class="keywordtype">unsigned</span> ch)
<a name="l00425"></a>00425 {
<a name="l00426"></a>00426     <span class="keywordflow">return</span> dev-&gt;getNRanges(sd, ch);
<a name="l00427"></a>00427 }
<a name="l00428"></a>00428 <span class="keywordtype">int</span> comedi_get_krange(comedi_t *dev, <span class="keywordtype">unsigned</span> sd, <span class="keywordtype">unsigned</span> ch, <span class="keywordtype">unsigned</span> r, comedi_krange *out)
<a name="l00429"></a>00429 {
<a name="l00430"></a>00430     <span class="keywordflow">return</span> dev-&gt;getKRange(sd, ch, r, out);
<a name="l00431"></a>00431 }
<a name="l00432"></a>00432 lsampl_t comedi_get_maxdata(comedi_t *dev, <span class="keywordtype">unsigned</span> sd, <span class="keywordtype">unsigned</span> ch)
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434     <span class="keywordflow">return</span> dev-&gt;getMaxData(sd, ch);
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 <span class="keywordtype">int</span> comedi_dio_config(comedi_t *dev,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subdev,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chan,
<a name="l00437"></a>00437                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> io)
<a name="l00438"></a>00438 {
<a name="l00439"></a>00439     <span class="keywordflow">return</span> dev-&gt;dioConfig(subdev, chan, io);
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 <span class="keywordtype">int</span> comedi_data_write(comedi_t *dev,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subdev,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chan,
<a name="l00442"></a>00442                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> range,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> aref,lsampl_t data)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444     (void)aref;
<a name="l00445"></a>00445     <span class="keywordflow">return</span> dev-&gt;dataWrite(subdev, chan, range, data);
<a name="l00446"></a>00446 }
<a name="l00447"></a>00447 <span class="keywordtype">int</span> comedi_data_read(comedi_t *dev,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subdev,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chan,
<a name="l00448"></a>00448                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> range,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> aref,lsampl_t *data)
<a name="l00449"></a>00449 {
<a name="l00450"></a>00450     (void)aref;
<a name="l00451"></a>00451     <span class="keywordflow">return</span> dev-&gt;dataRead(subdev, chan, range, data);
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="keywordtype">int</span> comedi_dio_bitfield(comedi_t * dev, <span class="keywordtype">unsigned</span> subdev, <span class="keywordtype">unsigned</span> mask,
<a name="l00455"></a>00455                         <span class="keywordtype">unsigned</span> *bits)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457     <span class="keywordflow">return</span> dev-&gt;dioBitField(subdev, mask, bits);
<a name="l00458"></a>00458 }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="keywordtype">int</span> rt_printk(<span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l00461"></a>00461 {
<a name="l00462"></a>00462     va_list ap;
<a name="l00463"></a>00463     va_start(ap, fmt);
<a name="l00464"></a>00464     <span class="keywordtype">char</span> buf[4096];
<a name="l00465"></a>00465     <span class="keywordtype">int</span> ret = vsnprintf(buf, <span class="keyword">sizeof</span>(buf)-1, fmt, ap);
<a name="l00466"></a>00466     va_end(ap);
<a name="l00467"></a>00467     buf[<span class="keyword">sizeof</span>(buf)-1] = 0;
<a name="l00468"></a>00468     <span class="keywordflow">if</span> (ret &gt;= 0 &amp;&amp; Emul::printFunctor) {
<a name="l00469"></a>00469         (*Emul::printFunctor)(buf);
<a name="l00470"></a>00470     }
<a name="l00471"></a>00471     <span class="keywordflow">return</span> ret;
<a name="l00472"></a>00472 }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="keywordtype">void</span> set_bit(<span class="keywordtype">unsigned</span> bit, <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *bits)
<a name="l00476"></a>00476 {
<a name="l00477"></a>00477     <span class="keywordtype">unsigned</span> word = bit/(<span class="keyword">sizeof</span>(*bits)*8), rem =  bit%(<span class="keyword">sizeof</span>(*bits)*8);
<a name="l00478"></a>00478     bits[word] |= (1UL&lt;&lt;rem);
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="preprocessor">#define BITS_PER_LONG (sizeof(long)*8)</span>
<a name="l00483"></a>00483 <span class="preprocessor"></span><span class="preprocessor">#define BITOP_WORD(nr)          ((nr) / BITS_PER_LONG)</span>
<a name="l00484"></a>00484 <span class="preprocessor"></span>
<a name="l00491"></a>00491 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> find_next_bit(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *addr, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size,
<a name="l00492"></a>00492                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> offset)
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *p = addr + BITOP_WORD(offset);
<a name="l00495"></a>00495         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = offset &amp; ~(BITS_PER_LONG-1);
<a name="l00496"></a>00496         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> tmp;
<a name="l00497"></a>00497 
<a name="l00498"></a>00498         <span class="keywordflow">if</span> (offset &gt;= size)
<a name="l00499"></a>00499                 <span class="keywordflow">return</span> size;
<a name="l00500"></a>00500         size -= result;
<a name="l00501"></a>00501         offset %= BITS_PER_LONG;
<a name="l00502"></a>00502         <span class="keywordflow">if</span> (offset) {
<a name="l00503"></a>00503                 tmp = *(p++);
<a name="l00504"></a>00504                 tmp &amp;= (~0UL &lt;&lt; offset);
<a name="l00505"></a>00505                 <span class="keywordflow">if</span> (size &lt; BITS_PER_LONG)
<a name="l00506"></a>00506                         <span class="keywordflow">goto</span> found_first;
<a name="l00507"></a>00507                 <span class="keywordflow">if</span> (tmp)
<a name="l00508"></a>00508                         <span class="keywordflow">goto</span> found_middle;
<a name="l00509"></a>00509                 size -= BITS_PER_LONG;
<a name="l00510"></a>00510                 result += BITS_PER_LONG;
<a name="l00511"></a>00511         }
<a name="l00512"></a>00512         <span class="keywordflow">while</span> (size &amp; ~(BITS_PER_LONG-1)) {
<a name="l00513"></a>00513                 <span class="keywordflow">if</span> ((tmp = *(p++)))
<a name="l00514"></a>00514                         <span class="keywordflow">goto</span> found_middle;
<a name="l00515"></a>00515                 result += BITS_PER_LONG;
<a name="l00516"></a>00516                 size -= BITS_PER_LONG;
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518         <span class="keywordflow">if</span> (!size)
<a name="l00519"></a>00519                 <span class="keywordflow">return</span> result;
<a name="l00520"></a>00520         tmp = *p;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 found_first:
<a name="l00523"></a>00523         tmp &amp;= (~0UL &gt;&gt; (BITS_PER_LONG - size));
<a name="l00524"></a>00524         <span class="keywordflow">if</span> (tmp == 0UL)         <span class="comment">/* Are any bits set? */</span>
<a name="l00525"></a>00525                 <span class="keywordflow">return</span> result + size;   <span class="comment">/* Nope. */</span>
<a name="l00526"></a>00526 found_middle:
<a name="l00527"></a>00527         <span class="keywordflow">return</span> result + __ffs(tmp);
<a name="l00528"></a>00528 }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="preprocessor">#define BITOP_MASK(nr)          (1UL &lt;&lt; ((nr) % BITS_PER_LONG))</span>
<a name="l00531"></a>00531 <span class="preprocessor"></span>
<a name="l00532"></a>00532 <span class="keywordtype">void</span> clear_bit(<span class="keywordtype">int</span> nr, <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *addr)
<a name="l00533"></a>00533 {
<a name="l00534"></a>00534         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask = BITOP_MASK(nr);
<a name="l00535"></a>00535         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *p = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)addr) + BITOP_WORD(nr);
<a name="l00536"></a>00536 
<a name="l00537"></a>00537         *p &amp;= ~mask;
<a name="l00538"></a>00538 }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 u32 random32(<span class="keywordtype">void</span>)
<a name="l00541"></a>00541 {
<a name="l00542"></a>00542     <span class="keyword">static</span> <span class="keywordtype">bool</span> rand_seeded = <span class="keyword">false</span>;
<a name="l00543"></a>00543     <span class="keywordflow">if</span> (!rand_seeded) {
<a name="l00544"></a>00544         srand(time(0));
<a name="l00545"></a>00545         rand_seeded = <span class="keyword">true</span>;
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547     <span class="keywordtype">double</span> r = (double)rand();
<a name="l00548"></a>00548     <span class="keywordflow">return</span> u32(r/RAND_MAX * 0xffffffffU);
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="keyword">static</span> <span class="keywordtype">int</span> mpctr = 0;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 <span class="keywordtype">int</span> register_module_param(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">void</span> *param, <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
<a name="l00554"></a>00554 {
<a name="l00555"></a>00555     <span class="keyword">using namespace </span>Emul;
<a name="l00556"></a>00556     ModuleParm mp;
<a name="l00557"></a>00557     <span class="keywordflow">if</span> (!moduleParms) moduleParms = <span class="keyword">new</span> ModuleParmMap;
<a name="l00558"></a>00558     ModuleParmMap::iterator it = moduleParms-&gt;find(name);
<a name="l00559"></a>00559     <span class="keywordflow">if</span> (it != moduleParms-&gt;end()) mp = it-&gt;second;
<a name="l00560"></a>00560     mp.p = param;
<a name="l00561"></a>00561     mp.name = name;    
<a name="l00562"></a>00562     mp.type = std::string(type) == <span class="stringliteral">"int"</span> ? ModuleParm::Int : ModuleParm::CharP;
<a name="l00563"></a>00563     (*moduleParms)[name] = mp;
<a name="l00564"></a>00564     <span class="keywordflow">return</span> ++mpctr;
<a name="l00565"></a>00565 }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="keywordtype">int</span> register_module_param_desc(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">void</span> *param, <span class="keyword">const</span> <span class="keywordtype">char</span> *desc)
<a name="l00568"></a>00568 {
<a name="l00569"></a>00569     <span class="keyword">using namespace </span>Emul;
<a name="l00570"></a>00570     <span class="keywordflow">if</span> (!moduleParms) moduleParms = <span class="keyword">new</span> ModuleParmMap;
<a name="l00571"></a>00571     ModuleParmMap::iterator it = moduleParms-&gt;find(name);
<a name="l00572"></a>00572     <span class="keywordflow">if</span> (it == moduleParms-&gt;end()) {
<a name="l00573"></a>00573         (*moduleParms)[name];
<a name="l00574"></a>00574         it = moduleParms-&gt;find(name);
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576     ModuleParm &amp; mp = it-&gt;second;
<a name="l00577"></a>00577     mp.name = name;
<a name="l00578"></a>00578     mp.p = param;
<a name="l00579"></a>00579     mp.desc = desc;
<a name="l00580"></a>00580     <span class="keywordflow">return</span> ++mpctr;
<a name="l00581"></a>00581 }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 hrtime_t gethrtime(<span class="keywordtype">void</span>)
<a name="l00584"></a>00584 {
<a name="l00585"></a>00585     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>hrtime_t<span class="keyword">&gt;</span>(Emul::getTime());
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="keyword">static</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> timeNowNS()
<a name="l00589"></a>00589 {
<a name="l00590"></a>00590     <span class="keyword">struct </span>timeval tv;
<a name="l00591"></a>00591     gettimeofday(&amp;tv, 0);
<a name="l00592"></a>00592     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(tv.tv_sec) * 1000000000LL + static_cast&lt;long long&gt;(tv.tv_usec)*1000LL;
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00596"></a>00596 <span class="keywordtype">int</span> isFastClock(<span class="keywordtype">void</span>)
<a name="l00597"></a>00597 {
<a name="l00598"></a>00598     <span class="keywordflow">return</span> Emul::fastFSM;
<a name="l00599"></a>00599 }
<a name="l00601"></a>00601 <span class="keywordtype">void</span> setFastClock(<span class="keywordtype">int</span> on_off)
<a name="l00602"></a>00602 {
<a name="l00603"></a>00603     Emul::fastFSM = on_off;
<a name="l00604"></a>00604 }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="keywordtype">void</span> clock_wait_next_period_with_latching(FifoHandlerFn_t handleFifos, <span class="keywordtype">unsigned</span> num_state_machines)
<a name="l00607"></a>00607 {
<a name="l00608"></a>00608     <span class="comment">/* NB: this function is really severely limited: it unconditionally </span>
<a name="l00609"></a>00609 <span class="comment">       waits for 1 clock cycle regardless of what's passed-in */</span> 
<a name="l00610"></a>00610 
<a name="l00611"></a>00611     <span class="comment">// try and sleep as close to 1 task cycle as possible, by remembering</span>
<a name="l00612"></a>00612     <span class="comment">// the last time we woke and sleep by "timeleft this period" amount..</span>
<a name="l00613"></a>00613     
<a name="l00614"></a>00614     <span class="comment">// also note clock latch support below..</span>
<a name="l00615"></a>00615 
<a name="l00616"></a>00616     <span class="keyword">static</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> lastWake = 0;
<a name="l00617"></a>00617     <span class="keywordtype">long</span> tick = 1000000000/Emul::taskRate(), amount = tick;
<a name="l00618"></a>00618     <span class="keywordflow">if</span> (!Emul::fastFSM) {
<a name="l00619"></a>00619         <span class="keywordflow">if</span> (lastWake) {
<a name="l00620"></a>00620             amount -= timeNowNS()-lastWake;
<a name="l00621"></a>00621             <span class="keywordflow">if</span> (amount &lt; 0) amount = 0;
<a name="l00622"></a>00622             <span class="keywordflow">if</span> (amount &gt; tick) amount = tick;
<a name="l00623"></a>00623         }
<a name="l00624"></a>00624         Emul::nanosleep(amount);
<a name="l00625"></a>00625     } 
<a name="l00626"></a>00626     lastWake = timeNowNS();
<a name="l00627"></a>00627     Emul::heartBeat();
<a name="l00628"></a>00628     <span class="comment">// check clock latch</span>
<a name="l00629"></a>00629     <span class="keywordflow">if</span> (Emul::latchTimeNanos &gt; 0) {
<a name="l00630"></a>00630         pthread_mutex_lock(&amp;Emul::latchMut);
<a name="l00631"></a>00631         <span class="keywordflow">while</span> (isClockLatched_Nolock()) {
<a name="l00632"></a>00632             <span class="keyword">struct </span>timespec ts;
<a name="l00633"></a>00633             Emul::clock_gettime(CLOCK_REALTIME, &amp;ts);
<a name="l00634"></a>00634             timespec_add_ns(&amp;ts, amount);
<a name="l00635"></a>00635             <span class="keywordflow">if</span> ( pthread_cond_timedwait(&amp;Emul::latchCond, &amp;Emul::latchMut, &amp;ts) == ETIMEDOUT ) {
<a name="l00636"></a>00636                 pthread_mutex_unlock(&amp;Emul::latchMut);
<a name="l00637"></a>00637                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> fsmid = 0; fsmid &lt; num_state_machines; ++fsmid)
<a name="l00638"></a>00638                     handleFifos(fsmid);
<a name="l00639"></a>00639                 pthread_mutex_lock(&amp;Emul::latchMut);
<a name="l00640"></a>00640             }
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642         pthread_mutex_unlock(&amp;Emul::latchMut);
<a name="l00643"></a>00643     } 
<a name="l00644"></a>00644 }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646 <span class="keywordtype">void</span> timespec_add_ns(<span class="keyword">struct</span> timespec *ts, <span class="keywordtype">long</span> ns)
<a name="l00647"></a>00647 {
<a name="l00648"></a>00648     ts-&gt;tv_nsec += ns;
<a name="l00649"></a>00649     <span class="keywordflow">if</span> (ts-&gt;tv_nsec &gt;= 1000000000) {
<a name="l00650"></a>00650         ts-&gt;tv_sec += ts-&gt;tv_nsec / 1000000000;
<a name="l00651"></a>00651         ts-&gt;tv_nsec = ts-&gt;tv_nsec % 1000000000;
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 <span class="keywordtype">int</span> clock_gettime_emul(<span class="keywordtype">int</span> clkid, <span class="keyword">struct</span> timespec *ts)
<a name="l00656"></a>00656 {
<a name="l00657"></a>00657     (void)clkid;
<a name="l00658"></a>00658     hrtime_t t = Emul::getTime();
<a name="l00659"></a>00659     ts-&gt;tv_sec = <span class="keyword">static_cast&lt;</span>time_t<span class="keyword">&gt;</span>(t/1000000000);
<a name="l00660"></a>00660     hrtime_t nsec = t - (<span class="keyword">static_cast&lt;</span>hrtime_t<span class="keyword">&gt;</span>(ts-&gt;tv_sec)*1000000000LL);
<a name="l00661"></a>00661     <span class="keywordflow">if</span> (nsec &gt;= 1000000000LL) ts-&gt;tv_sec += <span class="keyword">static_cast&lt;</span>time_t<span class="keyword">&gt;</span>(nsec/1000000000LL);
<a name="l00662"></a>00662     ts-&gt;tv_nsec = <span class="keyword">static_cast&lt;</span>time_t<span class="keyword">&gt;</span>(nsec) % static_cast&lt;unsigned long&gt;(1e9);
<a name="l00663"></a>00663     <span class="keywordflow">return</span> 0;
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666 <span class="keywordtype">int</span> seq_printf(<span class="keyword">struct</span> seq_file *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...) 
<a name="l00667"></a>00667 {
<a name="l00668"></a>00668     (void)m;
<a name="l00669"></a>00669     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bufsz = 262144*2;
<a name="l00670"></a>00670     <span class="keywordtype">char</span> * buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[bufsz];
<a name="l00671"></a>00671     va_list ap;
<a name="l00672"></a>00672     va_start(ap, fmt);
<a name="l00673"></a>00673     <span class="keywordtype">int</span> ret = vsnprintf(buf, bufsz, fmt, ap);
<a name="l00674"></a>00674     va_end(ap);
<a name="l00675"></a>00675     <span class="keywordflow">if</span> (ret &gt; -1) {
<a name="l00676"></a>00676         buf[bufsz-1] = 0;
<a name="l00677"></a>00677         Emul::procFileEmulStream &lt;&lt; buf;
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679     <span class="keyword">delete</span> [] buf;
<a name="l00680"></a>00680     <span class="keywordflow">return</span> ret;
<a name="l00681"></a>00681 }
<a name="l00682"></a>00682 
<a name="l00683"></a>00683 <span class="keyword">const</span> <span class="keywordtype">char</span> * GetTmpPath(<span class="keywordtype">void</span>)
<a name="l00684"></a>00684 {
<a name="l00685"></a>00685     <span class="keyword">static</span> std::string tmp = <span class="stringliteral">""</span>;
<a name="l00686"></a>00686     <span class="keywordflow">if</span> (!tmp.length()) {
<a name="l00687"></a>00687 <span class="preprocessor">#if defined(OS_WINDOWS)</span>
<a name="l00688"></a>00688 <span class="preprocessor"></span>        <span class="keywordtype">char</span> buf[256];    
<a name="l00689"></a>00689         GetTempPathA(<span class="keyword">sizeof</span>(buf), buf);
<a name="l00690"></a>00690         buf[<span class="keyword">sizeof</span>(buf)-1] = 0;
<a name="l00691"></a>00691         tmp = buf;
<a name="l00692"></a>00692 <span class="preprocessor">#else</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>        tmp = <span class="stringliteral">"/tmp/"</span>;
<a name="l00694"></a>00694 <span class="preprocessor">#endif</span>
<a name="l00695"></a>00695 <span class="preprocessor"></span>    }
<a name="l00696"></a>00696     <span class="keywordflow">return</span> tmp.c_str();
<a name="l00697"></a>00697 }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 int (*fsm_seq_show_func)(<span class="keyword">struct </span>seq_file *m, <span class="keywordtype">void</span> *dummy) = 0;
<a name="l00702"></a>00702 
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Sat Jan 10 10:30:46 2009 for FSMEmulator by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
